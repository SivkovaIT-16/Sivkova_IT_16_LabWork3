# Сивкова Екатерина ИТ-16. Лабораторная работа №3. Вариант 2.

# Задание 1
Инкапсуляция: private, геттеры и сеттеры, выбрасывание исключений через throw, класс RuntimeException и его наследники.

## Задача 4
### Текст задачи
Дроби.
Измените сущность Дробь из задачи 1.5.5. Реализуйте следующие требования:
- Дробь не может быть изменена после создания
- Необходимо корректно обрабатывать отрицательные значения.

Учтите, что знаменатель не может быть отрицательным. Продемонстрируйте работоспособность решения на примерах.

### Алгоритм решения
В классе Fraction объявлены финальные (гарантия неизменяемости дроби) поля numerator и denominator целочисленного типа. Реализованы только геттеры, сеттеры отсутствуют, потому что дробь не может быть изменена после создания. Конструктор по умолчанию создаёт дробь 2/3. Коструктор с параметрами проверяет, что значение знаменателя не равно 0, если валидация успешна, обрабатываются знаки (гарантия, что знаменатьль всегда положительный, знак записывается в числитель), далее вычисляется НОД, дробь сокращается и сохраняется в корректном виде. Конструктор копирования проверяет, что исходная дробь не null и создаёт копию уже упрощённой дроби. Для вычисления НОД используется приватный метод NOD с применением алгоритма Евклида. Реализованы операции сложения, вычитания, умножения, деления дробей. Также существуют те же операции с целыми числами (каждая операция имеет перегруженную версию). Все операции возвращают новые объекты Fraction.

В классе Validator реализованы статические методы: 
1. validateDenominator(int denominator) - если знаменатель равен нулю, выбрасывается исключение; 
2. validateFraction(Fraction fraction) - если дробь null или равна нулю (числитель 0), выбрасывается исключения; 
3. validateNumber(int number) - если число равно нулю, выбрасывается исключение.

Используются следующие типы исключений: 
1. IllegalArgumentException - некорректные параметры;
2. ArithmeticException - математические ошибки.

В основной программе продемонстрирована работа класса:
1. Создание дробей;
2. Вывод созданных дробей;
3. Арифметические операции;
4. Проверка вывода всех возможных исключений.

#### Тестирование
Созданы обекты:
1. Fraction f1 = new Fraction();
2. Fraction f2 = new Fraction(-1, 4);
3. Fraction f3 = new Fraction(3, -27);
4. Fraction f4 = new Fraction(-2, -8);
5. Fraction f5 = new Fraction(5,10);

Вывод:
1. f1 = 2/3
2. f2 = -1/4
3. f3 = -1/9
4. f4 = 1/4
5. f5 = 1/2
6. 2/3 + 1/2 = 7/6
7. 1/4 + 2 = 9/4
8. -1/9 - 1/4 = -13/36
9. -1/9 - 7 = -64/9
10. 1/2 * 1/2 = -1/8
11. 1/4 * 16 = 4/1
12. 1/2 / 2/3 = 3/4
13. -1/9 / 2 = -1/18
14. Ошибка: Знаменатель не может быть равен нулю.
15. Ошибка: Деление на нулевую дробь.
16. Ошибка: Деление на ноль.
17. Ошибка: Дробь не может быть null

## Задача 10 
### Текст задачи
Дороги.
Измените сущности из задачи 1.3.3. Гарантируйте, что между двумя городами может быть только одна прямая дорога (другой путь может быть проложен только транзитом через другие города). Города можно создавать с указанием заранее заданных путей, в любой момент времени можно добавить новую дорогу в любой город и удалить имеющуюся дорогу.

### Алгоритм решения
В классе Roads поля title - название города (String), ways - карта дорог к другим городам (Map<String, Integer>). Реализованы свойства: геттеры: getTitle(), getWays() (возвращает копию карты); сеттеры: setTitle(), setWays() - с валидацией. Конструктор по умолчанию создаёт город "A" без дорог. Конструктор с названием проверяет название города на пустоту, при успешной валидации создаёт город с пустой картой дорог. Конструктор с готовыми путями проверяет название города на пустоту и все пути в карте на корректные названия городов и стоимости путей, далее происходит проверка на отсутствие в карте путей дороги в себя (метод containsKey(title) - возвтращает true если в контейнере существует ключ title), при прохождении валидации создаётся город и копия карты дорог в соседние города. Конструткор копирования создаёт копию с названием города и картой дорог. Реализован метод добавления дороги в карту: проверка названия города назначения, проверка корректности стоимости пути, проверка отсутствия существующей дороги (если существует, выброс исключения с соответствующем сообщением об ошибке), проверка что дорога не ведет в себя (метод equals(city) - если названия городов одинаковые, возвращает true и выбрасывется исключение), при успешном прохождении проверок, добавление дороги в карту. Также есть метод для удаления дороги из карты: проверка существования дороги, при успехе удаление дороги из краты, иначе выброс исключения с сообщением, что дороги в город X не существует.

В классе Validator реализованы статические методы: 
1. validateTitle(String title) - если название города null или пустое, выбрасывается исключение; 
2. validateCost(int cost) - если значение стоимости отрицательное или равно нулю, выбрасывается исключение; 
3. validateWays(Map<String, Integer> ways) - если карта дорог содержит некорректные значения, выбрасывается исключение.

Используются следующие типы исключений: 
1. IllegalArgumentException - некорректные параметры;
2. IllegalStateException - объект находится в неподходящем состоянии для выполняемой операции.

В основной программе продемонстрирована работа класса:
1. Создание городов только с названием;
2. Добавление дорог по отдельности;
3. Создание города с готовыми дорогами;
4. Удаление существующего пути из карты дорог;
5. Проверка вывода всех возможных исключений.

#### Тестирование
Вывод:
1. Ошибка: Название города не может быть пустым.
2. Карта дорог:
- Набор путей из города A (название: стоимость).B: 3;C: 12;
- Набор путей из города B (название: стоимость).D: 6;
- Набор путей из города C (название: стоимость).A: 9;B: 2;
- Набор путей из города D (название: стоимость).A: 5;C: 7;
3. Ошибка: Нельзя создать дорогу в тот же город.
4. Ошибка: Дорога в город A уже существует.
5. Ошибка: Некорректное значение стоимости пути.
6. Изменённая карта дорог: 
- Набор путей из города A (название: стоимость).B: 3;
- Из города B нет путей.
- Набор путей из города C (название: стоимость).A: 9;B: 2;
- Набор путей из города D (название: стоимость).C: 7;
7. Ошибка: Название города не может быть пустым.
8. Ошибка: Некорректное значение стоимости пути.

# Задание 2
Разработка структур данных.

## Задача 5
### Текст задачи
Маршрут.
Данная задача предполагает разработку новой сущности на основе той, что была получена в задаче 1.4.8 (Город). Сущность Город может быть доработана по своему усмотрению для более удобного использования. Основная идея задачи в разработке такой сущности, которая будет представлять собой маршрут между двумя городами. Данный маршрут в любой момент времени можно получить как массив для дальнейшего использования. Сущность Маршрут имеет следующие характеристики:
- Имеет Город начала и Город конца пути.
- Инициализация Маршрута может быть выполнена только если указана точка начала и конца пути. Если указано nullзначение - то ошибка.
- Точку начала и конца можно изменить в любой момент времени, но они всегда должны существовать.
- Может вернуть массив Городов, представляющий собой маршрут из начала в конец. Массив содержит все Города (в порядке очереди) через которые надо пройти что бы попасть из Города начала в Город конца, причем и начало и конец также содержатся в этом массиве. Алгоритм формирования пути в данном случае не существенен, можно выбрать вариант со случайным путем, путем проходящим через наименьшее число городов, или самым дешевым путем. Если путь найти невозможно – возвращается пустой массив.
- Маршрут может быть приведен к строке, которая будет возвращать название всех городов маршрута в порядке очередности.
- Создание объекта и изменение точек начала и конца выполняется за константное время O(1).

Воспользуйтесь картой городов из задачи 1.3.3 и выведите маршрут из Города F в Город D.

### Алгоритм решения
В классе Route объявлены поля startCity (CreateCities) - город начала маршрута, endCity (CreateCities) - город конца маршрута, citiesMap (Map<String, CreateCities>) - карта всех доступных городов, где ключ - название города, значение - объект CreateCities. Реализованы свойства: геттеры getStartCity(), getEndCity() и сеттеры setStartCity(), setEndCity() - с валидацией. Конструктор с параметрами проверяет города отправления и назначения, создаёт копию карты всех городов. Конструктор копирования создаёт копию маршрута. В методе getRoute() создается пустой список для накопления пути, запускается рекурсивный поиск (метод findWay()), если путь найден преобразуем список в массив, иначе возвращаем пустой массив. Приватный метод findWay() - это рекурсивный метод для поиска пути: для каждого города в текущем пути проверяется, не посещали ли уже текущий город, добавляет текущий город в путь, при достижении конечного города возвращает true, для каждого соседнего города из карты дорог выполняется рекурсивный поиск, если путь не найден, текущий город удаляется из пути. Реализован метод toString(), который проверяет существование маршрута между городами. Если маршрута нет, возвращается строка с соответствующим сообщением. Если маршрут был найден, то инициализируется переменная result, в которую последовательно записываются города маршрута (пока город в маршруте не последний, города разделяются значком "->"), возвращается готовый маршрут. 

В классе Validator реализован статический метод: 
1. validateCity(CreateCities city) - если город null, выбрасывает  IllegalArgumentException - некорректные параметры.

В основной программе продемонстрирована работа класса:
1. Создание городов;
2. Добавление дорог;
3. Создание карты городов из задачи 1.3.3;
4. Поиск маршрутов.

#### Тестирование
Созданы обекты:
1. Route route1 = new Route(cityF, cityD, citiesMap);
2. Route route2 = new Route(cityA, cityC, citiesMap);
3. Route route3 = new Route(cityE, cityC, citiesMap);

Вывод:
1. Маршрут: F -> B -> A -> D
2. Маршрут: A -> B -> C
3. Маршрут: E -> F -> B -> A -> D -> C

# Задание 3
Наследование: extends, super, final, переопределение.

## Задача 1
### Текст задачи
Запретная Дробь.
Измените сущность Дробь, полученную в задаче 2.1.4. Гарантируйте, что невозможно создать
такой подвид дроби, который позволял бы создавать Дроби с изменяемым состоянием.

### Алгоритм решения
Класс ForbiddenFraction - final-класс, наследующий от Fraction, реализующий метод для создания неизменяемых дробей. Все конструкторы приватные (позволяет гарантировать неизменяемость объектов), создание объектов происходит через статические методы. Конструктор с параметрами вызывает родительский конструктор с числителем и знаменателем. Конструктор по умолчанию вызывает родительский конструктор по умолчанию. Реализованы статические методы для создания дроби. Метод create(int numerator, int denominator) - создает дробь с указанными числителем и знаменателем, использует приватный конструктор. Метод create() - создает дробь со значениями по умолчанию (2/3). Метод create(Fraction fraction) - выполняет проверку с помощью метода validateFraction(), создает копию существующей дроби. Метод toString() - вызывает метод родительского класса. Все арифметические операции объявлены как final, каждая операция вызывает соответствующий метод родительского класса и создает новый объект ForbiddenFraction. 

В классе Validator реализованы статические методы: 
1. validateDenominator(int denominator) - если знаменатель равен нулю, выбрасывается исключение; 
2. validateFraction(Fraction fraction) - если дробь null или равна нулю (числитель 0), выбрасывается исключения; 
3. validateNumber(int number) - если число равно нулю, выбрасывается исключение.

Используются следующие типы исключений: 
1. IllegalArgumentException - некорректные параметры;
2. ArithmeticException - математические ошибки.

В основной программе продемонстрирована работа класса:
1. Создание дробей;
2. Вывод созданных дробей;
3. Арифметические операции;
4. В комментариях кода показзаны запрещённые операции и методы создания дроби.

#### Тестирование
Созданы объекты:
1. ForbiddenFraction f1 = ForbiddenFraction.create();
2. ForbiddenFraction f2 = ForbiddenFraction.create(-1, 4);
3. ForbiddenFraction f3 = ForbiddenFraction.create(3, -27);
4. ForbiddenFraction f4 = ForbiddenFraction.create(-2, -8);
5. ForbiddenFraction f5 = ForbiddenFraction.create(5,10);

Вывод: 
1. f1 = 2/3
2. f2 = -1/4
3. f3 = -1/9
4. f4 = 1/4
5. f5 = 1/2
6. 2/3 + 1/2 = 7/6
7. 1/4 + 2 = 9/4
8. -1/9 - 1/4 = -13/36
9. -1/9 - 7 = -64/9
10. 1/2 * 1/2 = -1/8
11. 1/4 * 16 = 4/1
12. 1/2 / 2/3 = 3/4
13. -1/9 / 2 = -1/18

# Задание 4
Создание иерархий: abstract.
 
## Задача 2
### Текст задачи
Дробь это число.
Измените сущность Дробь, полученную в задаче 2.3.1. Дробь должна быть подтипом класса
Number. Данный класс входит в стандартную редакцию языка Java.

### Алгоритм решения
Класс FractionIsNumber наследуется от абстрактного класса Number. Поля numerator и denominator объявлены как final, что гарантирует неизменяемость объекта после создания. Конструктор по умолчанию cоздает дробь со значениями 2/3. Конструктор с параметрами проверяет, что знаменатель не равен нулю через Validator.validateDenominator(), если знаменатель отрицательный, знак переносится в числитель (гарантия положительного знаменателя), далее вычисляется НОД методом Евклида дробь сохраняется в упрощённом виде. Конструктор копирования создает копию существующей дроби с предварительной проверкой на null через Validator.validateFractionIsNumber().

Переопределены все абстрактные методы класса Number: 
- intValue() - возвращает целочисленное значение дроби (целочисленное деление);
- longValue() - возвращает длинное целочисленное значение;
- floatValue() - возвращает значение с плавающей точкой одинарной точности;
- doubleValue() - возвращает значение с плавающей точкой двойной точности.

 Реализованы основные арифметические операции, каждая из которых возвращает новый объект. Каждая операция имеет перегруженную версию для работы с целыми числами. Для приведения дроби к несократимому виду используется алгоритм Евклида в приватном методе NOD(). Берутся значения числителя и знаменателя, последовательно вычисляется остаток от деления до тех пор, пока остаток не станет равным нулю, последний ненулевой остаток является НОД. 

В классе Validator реализованы статические методы:
1. validateDenominator(int denominator) - если знаменатель равен нулю, выбрасывает исключение;
2. validateFractionIsNumber(FractionIsNumber fraction) - если дробь null или числитель равен нулю (при делении), выбрасывает исключения;
3. validateNumber(int number) - если число равно нулю (при делении), выбрасывает исключение.

Используются следующие типы исключений:
1. IllegalArgumentException - некорректные параметры (нулевой знаменатель, null-дробь);
2. ArithmeticException - математические ошибки (деление на ноль).

В основной программе продемонстрирована работа класса:
1. Создание дробей;
2. Вывод созданных дробей;
3. Преобразование типов - вызов методов intValue(), longValue(), floatValue(), doubleValue().

#### Тестирование
Созданы обекты:
1. FractionIsNumber f1 = new FractionIsNumber();
2. FractionIsNumber f2 = new FractionIsNumber(-200, -102);
3. FractionIsNumber f3 = new FractionIsNumber(-1, 4);
4. FractionIsNumber f4 = new FractionIsNumber(60, 8);
5. FractionIsNumber f5 = new FractionIsNumber(25, -10);
Вывод:
1. f1 = 2/3
2. f2 = 100/51
3. f3 = -1/4
4. f4 = 15/2
5. f5 = -5/2
6. Преобразование типов:
7. f2: 1.9607843137254901 (doubleValue())
8. f3: -0.25 (floatValue())
9. f4: 7 (longValue())
10. f5: -2 (intValue())

# Задание 5
Полиморфизм: виртуальный вызов метода, interface, implements.

## Задача 1
### Текст задачи
Сложение.
Разработайте метод, который принимает набор числовых значенийи возвращает их сумму в вещественной форме. С использованием данного метода выполните следующие сложения:
1. 2 + 3/5 + 2.3
2. 3.6 + 49/12 + 3 + 3/2
3. 1/3 + 1

### Алгоритм решения

#### Тестирование

# Задание 6
## Задача 5
### Текст задачи


### Алгоритм решения
#### Тестирование

# Задание 7
## Задача 1
### Текст задачи

### Алгоритм решения
#### Тестирование

## Задача 2
### Текст задачи

### Алгоритм решения
#### Тестирование

## Задача 3
### Текст задачи

### Алгоритм решения
#### Тестирование

# Задание 8
## Задача 4
### Текст задачи

### Алгоритм решения
#### Тестирование
